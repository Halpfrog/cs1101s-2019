// Question 1

// Link: https://sourceacademy.nus.edu.sg/playground#chap=4&exec=1000&ext=NONE&prgrm=PTAEEkDsGcBcCcCuBjWBLA9jUAzD9Q5EATAU0lmlAHcALDUAQ3lNEWjUgHNRZa0qeAgAd4jVGmSkAXAFgAUCAUhQACgCMASlABhDMICeTSMVDDGcVnwGhy6FrjQAbVp1gM%2BrUsTTuCGHFAAZQxEeClQAEFkRjIAWwNlMFAU0AAFJ0YDLnhQkyZYUFpYWGFoaRBoUPDScVjSBIA6SHZG70RG6C5gYUzs3MQTJLUAJm0AdXhfVgNqwgwnRHQsXHxbcVpeCwBrUE5eWlYQsIjo%2BoT0vpy84kbh1QBmbQAlQYPWUQwcxjjeD1I4KBZmF5otlpBQCtPKAuGgAG7kXgA2AxaAAu7yBRJEA43F4-EEwlE4m44YARUQyMwEPUkWxJIZjKZBKxijAk2mTFwgwkKwEAH0WsgXBgAEYWKy0RiFWCMbYArlwKbcJhUZhcRBxOzGUwsWBhbAISl7QKeYZKzg8FiiAF2NWgIUi8VojE4HngvbQQUoJ0S1TQbQAb1ZqVAKnGz3AABUAKKgAASMeeMYxob1BsIoAAvDnQAAiSJ50AAH2LmZzWfzOiLpfLubzAHEa2WqBX81G8wBuBQAX1ZrOZg6HDPJlLg1NA6gAQvTh3O5wP2VNYKxGNzILyIQLiJBGPylYx8nxpVt5fanAJCgFCAhLWroMN1ZrtYfdaR9fBDUhXIFSAj4EYpAuFqFA3sqVqkDaaIUPajqkGKEquu6E7bru%2B4IK%2BqgAB4BqAwaYvIobhpGsYJkmKYKGm74ZuIyCaogmQrqolGhqxKT%2BgANEwyB0XE2hZgAfJ63rCvBzqkP62gAGRSdxvEcSxbGhkapAKYRSmhjhmjdvIfYEYu86GUOo5Uis6g6LORlWcS-ZsqAHIrlybobh6yAYHEoqcJKJ6ymeXIXoC14ACIAHKRGBr5qvkbkeV5VCeL8bgMGuHDcC4wyheFB75NQvj0EsoDIFK3CWu8aD%2BPAZDwBiKgxlhPy9ACch2TFnmQBJAWwKonWqAWeZcY2-X5oWmhqSoPWDQN1YDR2A0jVxE3Vpoy06SoKjpp%2BVATYWA1NnNQ2TVWB2zcNB1LcMrVed1l7XXAvVNqNoATR2o3DItB07ad%2B2PRND0rcM63UZtT03YdeYnXm01fdDfW7XmmgKM5m6Fe5bUSThuH4YpYbsiRcaJsmqapBtEK0fRjESdjGmMMIwjkMQakaaGLROE4jNMykGPab2tmWdZ-N4iZ45mUFfMC%2BLi72cuq7rsjGBYV8iCHl5-LWow5VcXQkibL5Cprp1kKBLDR1wwNAAcRavsM4OW-kJPnpeewQlrRW2P%2BRh5hbnqgNamRSKYooe02SEuRO8uK8r7Wq5B6vwNhmMhqkxHRvj5FEykJOgHENPYdmQlYdm9ZewA-PmTagNIoBYVxWk6Xptni43gt2RSpk0jGYtN1ZksOTLSMejgnDEPyXDkKQ6HMDKUoynKeugJlEX5BYTDwBqIGFK%2BjgmPFhzmhhS84CuBDQoP8CBTxYQsBurDXpEUYNo0ECBMCBD9xOg8mCPY8T-AhQf8QUVhh3wbIQUgABHSk18uK%2BB9kDQ0hxViswwLlFUaIIHkAiPsNcWBSAAFogING1J1R%2B4BTSHAcDYSADBgHmnAZAqQXF-5fyjnASesCPzwK8HEYQsAjAGxZk4GqYAmGjxYbKX%2Bt0urG0hh9Y6B09rtlkVNeGq0wCAw4VtG6z0lFHWWsMER39WESO2nI-aptFFmIsWXFRAMwD2xBndARCM7IGLEZPSRvVPo20sWDCGXioaDW5nZdRBoqACMRshFYrjx5GK6lpPCicUjJ1IgTCi6kUhoECN1cgXA%2BDx20AJSsTwEnpNYpktQhxYj5MLpWPqoAZKgCpkpSpxBVCymcPk-i9YOz1Kkk0tiLS2nqycEMjpWllo1OsUGfprFM49XaSMhZoyRnjP%2BqU0MPZbBODRCUjmGc4Fb2HqImJ4iupLPGTpDSekNlbJ2fhDSmcBGXNSHpeuBEu5dyFh6dQAAxTuHz5w92lk5SJEJon8npgcE8-97THM1vwV2NhoRoPoawRAwg-igFFAVKhsBhicGFCQUq0J2pYUKHAfQKNiBYBIWQ1gb8olD2YePSFMKuRwr2IUexMDOCPkhO1fBwEiGXlpZy0A1KFS4sOeyse0CuVwJ3lwnhfDHYCKEYc5lEKTAeOkX4s6piYZ7Wtl4vV30glrTsQqhxXUTEzR0TIvRLimXHK1a07R5jpEmvtUtc1ajLUaOtaoJx%2BjnXf3pjqr1PiAkBK8Uauyur4a%2Bpxuw0JDoGJOGGFGSIDYuJZvCpve%2BdJ5AMrBaGqO4b4n3NSNjZJqdCbYxLUUICdM444S4mTPiuylLlOydwPJ8TCmgGKVWjmLgZ48ErIM%2BJABqJtVTzkBm0LOwZSyF3LSCXsxp6zu1ZNlBO7p2bmxbH3bUvNR692TPBg2EaXbN37I4YGlg-40SqA7WszdmygJ3JmQ8g5hwnAtuWfkri5hyqqCnQGdtF8%2BIbr2dcpSn7tmsBHUzR56bnlsU2djeDKRsaZ3-YBttabWZBLeQCxuXyJzqAbP88jxl3lLk5GuRtjBWbMp3tCoeapWYwjHlQLBMJ4SIgXtlW4oAowIJLY%2BNjxyqDQHyk4N8D79aO2CmFReADH4AE1QiFUPKqaAz4oWFFk%2BKhgUqMD-kyMIfFEJoScGEAVET%2B8xMhQwI5Y8hRqCsGpQ6dzexuEYB2YeIwLALRyzswglwfbNjXjXMc9VdUGouGaioVjTh2M6tNVYsGMbTHGvtQo7xhqlHWwhkVyN1ifEvSTSE4GPV3rfQWqDEaziImhxWOlzLlbEnJojCnMi9bSljpvGwys4LYn5Iw1u0MPaBQCP9KciZKGqIPqedh25yGZkjcheNstLLtWDNie%2BpSMy5tegW-TZbP6U2fmI04abNyv1be3atjMoG46DKu%2B2mTfHwO1Facdk7mHsM8wY3R6ytGIdMih9Dkc%2Bk2QViR8jlHqO0fo4x6jzN-BBCgu9p8OEaAyCmCED7QYkBiUIJXHAVEAJbPvGCNUU4MR4hGAyFka4gxbjY9IEYZgrAQoAHkoxmDYdeaE4h9SsaROOFUOBxDOF8EYAnRPvD04l6gJWTh0hiAkDEbXkRoBoiN%2BvIRmPzcW8t%2Bj9ryMLBogkTgLi1PYCCh%2BKpXAu4tQJ1KT4aAvQshtORK7rUoBZ15krkWWdqgcCqG0KXPMaRIhBCCEWCPPzIjgAADKJrrkkK3%2BeC%2BY95myOHhlM3Il0BKQQawyS0lh6XokrI7ekAkdjWPedb2zIOXQ1jqh5s%2BjEn6PMABZZgBh4aMNY2iWDKQezsxSHmWvkRcFpAAAzqH6tjAA2gAcn76JBCaId8AF0FBBIUM31vpT2%2BCU729u7PeRn799C%2Bm2j0VIz9AHP7Gi-aQr9XyMJvqUrvs-oPkfqfvIOfvIJfl1G3vxEJCtsTN3hAr3qAYfhJHmAAHrYET64BT6kCf7f6lK-7L5r4PBAGhggEXYD7oEn5n46QX5G4t6wHX7wF35IEPqP597UEH7iS9Sj4AS4Hy5IaEHz75hL64JRjr4UGpBUEiQv6kB0GQEMHQFMFX6hg34IEzKZxcFoF8GBJO7fiiE-4SFSGAFiFyFwS0EQFQEwHMSsEd6IH3oZi6E8EKGeK4Ef7TZEGhgkGSGr7kEWF75uFgGKE2EqF2FwGOHaHIFa7cHyGhG9RZoPST4iHeFiF%2BFSEAAsMhKQlhNB4kShthahLBGhbBTht2EIrhCR6BvUS0hhlIxhxBphq%2BAArLkaAPkbwRKEUSoQZA3sOOXoCDoFXqsAQLXjOCXgMfRowfbqUakJoewc4Q-igU-l6DuHuKJhGvIrIstA0QQekSYdOP-hvkEahJsS5r0U3iUfYWUdEa9pUbYKsfERsehGINqravmFOAdN8WaqkdPocc0ccWvuYdvsEfyK8aJlcQjpEQ4bfhUToc8ecW8ZhO6lVrou-kYYCb4RMf-oEWCciVCeEbZLCXcfCTEZwUiesWhFsWiWDILiUBgImv8QcdhhkbiWvjkWcdSRce8cQNCbMcwbcQseURSS4VSRCTSS5lljscogNN8XsXgWkWyUcVOP4acQSSEdYfQdcXMcKexKKQ8YiXEYSdKU4vsU0TiccWYR0V0QoQKaoXqVEeSUabEagTySiR8S1vaq1hadiakL-mqVIficAeCVYYUcSQRKSSKfcb%2BpSSaR6bSaDPyPajViyZaQGbidkbaWGQUT0ZGYKeoTGS6XGeKQmZKbyaiaDOVvqjNGmUqQCSqUCUGW0TmXofmTqQjvXtMc3CoFGBXiMcbmMaALXhZFMT2TDlGTcc6Voa6fGb3pdO1B4p8WDJVn1K9A8XeneiYhuVuXuaxL9IVomrufuakCuRVgap6rKSVsDl-uyeZCcTmYuWEZ2YWfMQabGUpMaQuajFdA1qDCkTdqeUpIeSecBVuY1jlgEi9GIeBXsjuXsUBaOgBdeTInanKTlq1v6QvqOf-qCaGc%2BQ6dGR%2BSWV%2BW6SMs%2Bcud6T4vNEhXBSkKBbBfRRpJBblnImBcxUzCuT6hxaeSuV4rGrWeiWhZhfqreT4ZmQ%2BVIRqQRb%2Be1ERdOXCbOaWSsXEZReaXRRpE4theIVJQAU%2BXJS%2BcobqUKTOUsY8VwZRT1E4rxfudpU2VaToP4SGZQTvoRQWY6aZUpeZd%2BRRYZVRXdOuYhZuZughTpb-k5dmUEe5a%2BZ5UWSRcpWRfOX5bFEudZemlxAIs1oFTVrZXudouJfeZFa2dFYZQ6f0ROYyEMYUIOQqKTrXqLOOZVSSCZfFWoIaSpVUc8eHBqJHOPGrGBiuRbD4sNSbKJcosFfReeUeRhcVtIj6uFQ1Y%2BUET1UrBTlHANfAApU6d5QieRaoKtX1dHB9jqqNZ7AdGdZdcyZpSBShR6kVg9Tng5ZJUFOqTmYdetf1THOVNtV5WSYlWxL5QdQrL1Z9cdbHNsTRbsXlRBdRTDAJU9aUhJTheoK9TaStSDWtSrJtb9W1YsXtclcDRHGDZtUGumjDXevZUjfeWjQEe9ZjUdTjR5cRe1Z%2BYDftR9djd9XHCuTWbNRbJNXBbzahQEn9Itajf4VyWCZzRtdzbje%2BazaRezYTTLV9SdRNGdT6kxflXdRieLbTe0RjcTVzR9uVeDs1fDn2QOaMfVeoB3E1RbYSK1QrfjWKapb3hNqcpDWNQmh6tlg6hTaFVotWd6seeLTGMtWCZ7ZPPLfqYrQDV3oTdHcYnDXNf4qhf7VrTdWxFTRsveRHSCTmcnbALHWZQTWWR7ftj-Daqnf7UVv7TWYLeBelSRhmSjQXXTUEcXaXbtW7V1XEcXWTSRtrVubnS8vnW9V3VXbEj3f9T5ftYPfxamahWuX9CPducHYFavWHc9e3f4fha5d3czYpXPeXe7SMovbXSLRnaHU3cBf%2BYFaLZeeneuuHc5UXdPacrPcWQnffv3ZXZ-C6pNsLdVsvaA3faeWPbPhPVFVHZ-THR5RVY7U7XZP2cMTbTXr8t2c1c7XHa7XORXRfVXeGtNT4vXT6c-dDevUHXdKQzeYVUcT8pHaGeCvTN-QlfPUncQ16VvZQ7NXlh6l6hA3ZeTeLUw4XVPYA2GiYOw-HZw4Q9Htw26iHYI2AzDFnSFfBTdDZWI3iR-VI%2BWjI8fTtafX3U8QPUozqkVtBSvXw6dMIzrbQ7rQHW3bpUw9Jfo0ctI-ycY39T-fI%2BfYowYwdsozlXYyJdIheXag46PaI7vW4-vZ45qmw743jR1UlQo6wzw1Iv7dvVGtdZo8hY4uTa47-u453XA8E66mbdg5VdVZXkObbTRg7cg83G%2BXg%2Bk8rQo11rJjqjY1DR6ho-RVA3eUcQ2Mw65T03xrI-g51eY73lM%2B1NAN7b7cJenehdnXBZEzsTExvU47wxNQw0CeMxI2CYswCDM504nd079kszKaA4M2A5s%2BBVeX7TNV9M88BXNVEzlj82-oHVo-s1Inlj9N6a-fE7-icxU6Gec9ANCUAA

// Instructions for students who are using this for practice:
//
// (1) Copy and paste this entire file into the editor of Source Academy
//     Playground at https://sourceacademy.nus.edu.sg/playground
// (2) Write your solution for each task in the Source Academy Playground.
// (3) Run the program to test your solution on the given testcases.

////////////////////////////////////////////////////////////
// Question 1A
////////////////////////////////////////////////////////////

// Write a function is_nucleobase that takes a string as argument and returns true if the
// string represents a nucleobase.
https: function is_nucleobase(s) {
  // WRITE HERE.
  return s === "A" || s === "C" || s === "G" || s === "T";
}

////////////////////////////////////////////////////////////
// Question 1B
////////////////////////////////////////////////////////////

// Write a function is_dna_strand that takes a list of strings as
// argument and returns true if every element string represents a nucleobase.
function is_dna_strand(xs) {
  // WRITE HERE.
  return accumulate((s, accum) => is_nucleobase(s) && accum, true, xs);
}

////////////////////////////////////////////////////////////
// Question 1C
////////////////////////////////////////////////////////////

// Write a function combine that takes a list of DNA strands and combines them into a single
// DNA strand without changing their order.
// Examples:
// combine(list(list("A", "G", "A"),
// list("G", "C", "T", "A"), list("C")));
// // returns list("A", "G", "A", "G", "C", "T", "A", "C")
// combine(list(list("G"), list("T"),
// list("C", "A", "A", "A"), list("G")));
// // returns list("G", "T", "C", "A", "A", "A", "G")
function combine(xss) {
  // WRITE HERE.
  return accumulate(append, null, xss);
}

////////////////////////////////////////////////////////////
// Question 1D
////////////////////////////////////////////////////////////

// Write a function oxoguanine_repair, which takes a list of "A", "C", "G", "8" and
// "T" and returns a list in which every "8" is replaced by "G".
function oxoguanine_repair(xs) {
  // WRITE HERE.
  return map(x => (x === "8" ? "G" : x), xs);
}

////////////////////////////////////////////////////////////
// Question 1E
////////////////////////////////////////////////////////////

// Write a function find_gene_start that takes a DNA strand as argument and finds the
// strand after the first occurrence of ATG. If your function find_gene_start finds an
// ATG sequence, it returns the following sequence in a one-element list. If there is no ATG
// sequence, find_gene_start returns the empty list null.
// find_gene_start(list("A", "C", "A", "T", "G", "T", "A", "C");
// // returns list(list("T", "A", "C"))
// find_gene_start(list("A", "T", "A", "G", "T", "A", "T", "G");
// // returns list(null)
// find_gene_start(list("A", "T", "A", "G", "T", "A", "C", "G");
// // returns null
function find_gene_start(xs) {
  // WRITE HERE.
  if (length(xs) >= 3) {
    if (
      head(xs) === "A" &&
      head(tail(xs)) === "T" &&
      head(tail(tail(xs))) === "G"
    ) {
      return list(tail(tail(tail(xs))));
    } else {
      return find_gene_start(tail(xs));
    }
  } else {
    return null;
  }
}

////////////////////////////////////////////////////////////
// Question 1F
////////////////////////////////////////////////////////////

// Write a function find_gene_end that finds a gene, which is the sequence up to but not
// including the next stop codon. If the function find_gene_end finds a gene, it returns it in
// a one-element list. If it does not find a gene, it returns the empty list null.
// find_gene_end(list("A", "T", "A", "C", "T", "A", "G",
// "A", "T", "A", "A"));
// // returns list(list("A", "T", "A", "C"))
// find_gene_end(list("T", "G", "A", "A", "T", "A", "C"));
// // returns list(null)
// find_gene_end(list("A", "T", "A", "C", "C", "A", "G",
// "A", "T"));
// // returns null
// TAG, TAA and TGA
function find_gene_end(xs) {
  // WRITE HERE.
  function helper(xs, accum) {
    if (length(xs) >= 3) {
      let tag = head(xs) + head(tail(xs)) + head(tail(tail(xs)));

      if (tag === "TAG" || tag === "TAA" || tag === "TGA") {
        return list(reverse(accum));
      } else {
        return helper(tail(xs), pair(head(xs), accum));
      }
    } else {
      return null;
    }
  }

  return helper(xs, null);
}

////////////////////////////////////////////////////////////
// Question 1G
////////////////////////////////////////////////////////////

// Write a function all_genes that finds all genes in a given DNA strand. The function
// all_genes should return a list of DNA strands. You can assume that genes do not overlap
// in the input DNA strand. Note that we do not impose any restriction on the length of a gene.
// Example:
// all_genes(list("T", "A", "T", "G", "C", "A", "T",
// "A", "A", "G", "T", "A", "G", "A",
// "T", "G", "A", "T", "G", "A", "T"));
// // returns list(list("C", "A"), list("A"))

function all_genes(xs) {
  // WRITE HERE.
  let start = find_gene_start(xs);

  if (is_null(start)) {
    return null;
  } else {
    let end = find_gene_end(head(start));

    if (is_null(end)) {
      return null;
    } else {
      return pair(head(end), all_genes(head(start)));
    }
  }
}

////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////

//===========================================================
// This function is provided for running the testcases
// in the Source Academy Playground.
// They are NOT part of the actual testing facility provided
// in the actual Practical Assessment.
//===========================================================
function assert(f, test_name, fnames) {
  display(test_name + ": " + (f() ? "PASS" : "FAIL"));
}
//===========================================================

////////////////////////////////////////////////////////////
// Test Cases for Q1A
////////////////////////////////////////////////////////////

assert(
  () => {
    return equal(is_nucleobase("Mary"), false);
  },
  "Q1A-P01",
  ["is_nucleobase"]
);

assert(
  () => {
    return equal(is_nucleobase("T"), true);
  },
  "Q1A-P02",
  ["is_nucleobase"]
);

assert(
  () => {
    return equal(is_nucleobase("^^^"), false);
  },
  "Q1A-P03",
  ["is_nucleobase"]
);

assert(
  () => {
    return equal(is_nucleobase("Mary"), false);
  },
  "Q1A-T01",
  ["is_nucleobase"]
);

assert(
  () => {
    return equal(is_nucleobase("G"), true);
  },
  "Q1A-T02",
  ["is_nucleobase"]
);

assert(
  () => {
    return equal(is_nucleobase("A"), true);
  },
  "Q1A-T03",
  ["is_nucleobase"]
);

assert(
  () => {
    return equal(is_nucleobase("TAG"), false);
  },
  "Q1A-T04",
  ["is_nucleobase"]
);

assert(
  () => {
    return equal(is_nucleobase("C"), true);
  },
  "Q1A-T05",
  ["is_nucleobase"]
);

////////////////////////////////////////////////////////////
// Test Cases for Q1B
////////////////////////////////////////////////////////////

assert(
  () => {
    return equal(is_dna_strand(list("A", "G", "A")), true);
  },
  "Q1B-P01",
  ["is_dna_strand"]
);

assert(
  () => {
    return equal(is_dna_strand(list("A", "B", "B", "A")), false);
  },
  "Q1B-P02",
  ["is_dna_strand"]
);

assert(
  () => {
    return equal(is_dna_strand(list("T", "G", "C")), true);
  },
  "Q1B-P03",
  ["is_dna_strand"]
);

assert(
  () => {
    return equal(is_dna_strand(list("T", "G", "Otto")), false);
  },
  "Q1B-P04",
  ["is_dna_strand"]
);

assert(
  () => {
    return equal(is_dna_strand(list("T", "G", "C", "B")), false);
  },
  "Q1B-T01",
  ["is_nucleobase"]
);

assert(
  () => {
    return equal(is_dna_strand(null), true);
  },
  "Q1B-T02",
  ["is_nucleobase"]
);

assert(
  () => {
    return equal(is_dna_strand(list("A", "A", "A")), true);
  },
  "Q1B-T03",
  ["is_nucleobase"]
);

assert(
  () => {
    return equal(is_dna_strand(list("_", "A", "T")), false);
  },
  "Q1B-T04",
  ["is_nucleobase"]
);

assert(
  () => {
    return equal(is_dna_strand(list("T", "G", "C", "TT")), false);
  },
  "Q1B-T05",
  ["is_nucleobase"]
);

////////////////////////////////////////////////////////////
// Test Cases for Q1C
////////////////////////////////////////////////////////////

assert(
  () => {
    return equal(
      combine(
        list(list("A", "G", "A", "T", "A"), list("A"), list("G", "A", "G"))
      ),
      list("A", "G", "A", "T", "A", "A", "G", "A", "G")
    );
  },
  "Q1C-P01",
  ["combine"]
);

assert(
  () => {
    return equal(
      combine(list(list("G"), list("G"), list("C", "T", "C", "T"), list("A"))),
      list("G", "G", "C", "T", "C", "T", "A")
    );
  },
  "Q1C-P02",
  ["combine"]
);

assert(
  () => {
    return equal(
      combine(
        list(
          list("A", "A", "A"),
          list("G"),
          list("C", "G", "C", "T"),
          list("A", "C")
        )
      ),
      list("A", "A", "A", "G", "C", "G", "C", "T", "A", "C")
    );
  },
  "Q1C-T01",
  ["combine"]
);

assert(
  () => {
    return equal(combine(null), null);
  },
  "Q1C-T02",
  ["combine"]
);

assert(
  () => {
    return equal(combine(list(null)), null);
  },
  "Q1C-T03",
  ["combine"]
);

assert(
  () => {
    return equal(combine(list(list("A"))), list("A"));
  },
  "Q1C-T04",
  ["combine"]
);

assert(
  () => {
    return equal(combine(list(null, null, list("T"))), list("T"));
  },
  "Q1C-T05",
  ["combine"]
);

////////////////////////////////////////////////////////////
// Test Cases for Q1D
////////////////////////////////////////////////////////////

assert(
  () => {
    return equal(
      oxoguanine_repair(list("A", "8", "A", "8", "C", "T", "A", "C")),
      list("A", "G", "A", "G", "C", "T", "A", "C")
    );
  },
  "Q1D-P01",
  ["oxoguanine_repair"]
);

assert(
  () => {
    return equal(
      oxoguanine_repair(list("8", "8", "8", "8", "8")),
      list("G", "G", "G", "G", "G")
    );
  },
  "Q1D-T01",
  ["oxoguanine_repair"]
);

assert(
  () => {
    return equal(
      oxoguanine_repair(list("A", "A", "A", "A")),
      list("A", "A", "A", "A")
    );
  },
  "Q1D-T02",
  ["oxoguanine_repair"]
);

assert(
  () => {
    return equal(oxoguanine_repair(null), null);
  },
  "Q1D-T03",
  ["oxoguanine_repair"]
);

assert(
  () => {
    return equal(
      oxoguanine_repair(list("A", "T", "G", "C", "8")),
      list("A", "T", "G", "C", "G")
    );
  },
  "Q1D-T04",
  ["oxoguanine_repair"]
);

assert(
  () => {
    return equal(oxoguanine_repair(list("8", "C")), list("G", "C"));
  },
  "Q1D-T05",
  ["oxoguanine_repair"]
);

////////////////////////////////////////////////////////////
// Test Cases for Q1E
////////////////////////////////////////////////////////////

assert(
  () => {
    return equal(
      find_gene_start(list("A", "C", "A", "T", "G", "T", "A", "C")),
      list(list("T", "A", "C"))
    );
  },
  "Q1E-P01",
  ["find_gene_start"]
);

assert(
  () => {
    return equal(
      find_gene_start(list("A", "T", "A", "C", "G", "T", "A", "C")),
      null
    );
  },
  "Q1E-P02",
  ["find_gene_start"]
);

assert(
  () => {
    return equal(
      find_gene_start(list("A", "T", "A", "G", "T", "A", "T", "G")),
      list(null)
    );
  },
  "Q1E-P03",
  ["find_gene_start"]
);

assert(
  () => {
    return equal(find_gene_start(null), null);
  },
  "Q1E-T01",
  ["find_gene_start"]
);

assert(
  () => {
    return equal(
      find_gene_start(list("A", "A", "A", "T", "G", "A", "T", "G")),
      list(list("A", "T", "G"))
    );
  },
  "Q1E-T02",
  ["find_gene_start"]
);

assert(
  () => {
    return equal(
      find_gene_start(list("A", "T", "G", "C", "G", "T", "A", "C")),
      list(list("C", "G", "T", "A", "C"))
    );
  },
  "Q1E-T03",
  ["find_gene_start"]
);

assert(
  () => {
    return equal(
      find_gene_start(list("A", "T", "A", "T", "A", "T", "A", "T")),
      null
    );
  },
  "Q1E-T04",
  ["find_gene_start"]
);

////////////////////////////////////////////////////////////
// Test Cases for Q1F
////////////////////////////////////////////////////////////

assert(
  () => {
    return equal(
      find_gene_end(list("A", "G", "A", "G", "T", "A", "A", "T", "A", "A")),
      list(list("A", "G", "A", "G"))
    );
  },
  "Q1F-P01",
  ["find_gene_end"]
);

assert(
  () => {
    return equal(
      find_gene_end(list("A", "T", "A", "C", "C", "A", "G", "A", "T")),
      null
    );
  },
  "Q1F-P02",
  ["find_gene_end"]
);

assert(
  () => {
    return equal(
      find_gene_end(list("T", "G", "A", "A", "T", "A", "C")),
      list(null)
    );
  },
  "Q1F-P03",
  ["find_gene_end"]
);

assert(
  () => {
    return equal(
      find_gene_end(list("G", "C", "T", "G", "A", "T", "A", "A")),
      list(list("G", "C"))
    );
  },
  "Q1F-T01",
  ["find_gene_end"]
);

assert(
  () => {
    return equal(
      find_gene_end(list("T", "T", "A", "C", "A", "G", "A", "T")),
      null
    );
  },
  "Q1F-T02",
  ["find_gene_end"]
);

assert(
  () => {
    return equal(
      find_gene_end(list("T", "A", "A", "T", "G", "A", "C")),
      list(null)
    );
  },
  "Q1F-T03",
  ["find_gene_end"]
);

////////////////////////////////////////////////////////////
// Test Cases for Q1G
////////////////////////////////////////////////////////////

assert(
  () => {
    return equal(all_genes(list("C", "T", "A", "A", "G", "C")), null);
  },
  "Q1G-P01",
  ["all_genes"]
);

assert(
  () => {
    return equal(
      all_genes(list("A", "A", "T", "G", "A", "C", "T", "A", "G", "G")),
      list(list("A", "C"))
    );
  },
  "Q1G-P02",
  ["all_genes"]
);

assert(
  () => {
    return equal(
      all_genes(
        list(
          "T",
          "A",
          "T",
          "G",
          "C",
          "A",
          "T",
          "A",
          "A",
          "G",
          "T",
          "A",
          "G",
          "A",
          "T",
          "G",
          "A",
          "T",
          "G",
          "A",
          "T"
        )
      ),
      list(list("C", "A"), list("A"))
    );
  },
  "Q1G-P03",
  ["all_genes"]
);
